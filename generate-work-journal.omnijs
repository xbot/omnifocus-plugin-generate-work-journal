/*{
    "type": "action",
    "targets": ["omnifocus"],
    "author": "Donie",
    "identifier": "org.0x3f.generate_work_journal",
    "version": "3.0",
    "description": "Assemble work logs of today and put them in clipboard.",
    "label": "Generate work journal",
    "shortLabel": "Generate work journal",
    "paletteLabel": "Generate work journal",
    "image": "list.number"
}*/
(() => {
    let preferences = new Preferences();

    const devPlugin = PlugIn.find('org.0x3f.libdev');

    if (devPlugin === null) {
        throw new Error('Dev library plugin not installed.');
    }

    const libdev = devPlugin.library('libdev');

    // Preference keys
    const PREF_DONE_LABEL       = 'done_label';
    const PREF_GENERIC_PROJECTS = 'generic_project_ids';
    const PREF_IGNORED_TAGS     = 'ignored_tag_ids';
    const PREF_JOURNAL_FOLDER   = 'journal_folder_id';
    const PREF_OUTPUT_FORMAT    = 'output_format';

    // Preferences dialog field labels
    const LABEL_DONE_LABEL       = 'Label for the done status';
    const LABEL_GENERIC_PROJECTS = 'Generic projects';
    const LABEL_IGNORED_TAGS     = 'Ignored tags';
    const LABEL_JOURNAL_FOLDER   = 'Work journal folder';
    const LABEL_OUTPUT_FORMAT    = 'Output format';

    // Output format option keys
    const OF_KEY_PLAIN_TEXT              = 'plain_text';
    const OF_KEY_MARKDOWN_ORDERED_LIST   = 'markdown_ordered_list';
    const OF_KEY_MARKDOWN_UNORDERED_LIST = 'markdown_unordered_list';

    // Output format option labels
    const OF_LABEL_PLAIN_TEXT              = 'Plain text';
    const OF_LABEL_MARKDOWN_ORDERED_LIST   = 'Markdown ordered list';
    const OF_LABEL_MARKDOWN_UNORDERED_LIST = 'Markdown unordered list';

    function prompt_preferences_dialog() {
        // Work journal folder

        const folderIds   = flattenedFolders.map(folder => folder.id.primaryKey);
        const folderNames = flattenedFolders.map((folder) => {
            let label = folder.name;

            while (folder.parent !== null) {
                label = folder.parent.name + " > " + label;
                folder = folder.parent;
            }

            return label;
        });

        const journalFolderId = libdev.getString(preferences, PREF_JOURNAL_FOLDER);

        const journalFolderOption = new Form.Field.Option(
            PREF_JOURNAL_FOLDER,
            LABEL_JOURNAL_FOLDER,
            folderIds,
            folderNames,
            journalFolderId
        );

        // Output format

        const outputFormat = libdev.getString(preferences, PREF_OUTPUT_FORMAT);

        const outputFormatOption = new Form.Field.Option(
            PREF_OUTPUT_FORMAT,
            LABEL_OUTPUT_FORMAT,
            [OF_KEY_PLAIN_TEXT, OF_KEY_MARKDOWN_ORDERED_LIST, OF_KEY_MARKDOWN_UNORDERED_LIST],
            [OF_LABEL_PLAIN_TEXT, OF_LABEL_MARKDOWN_ORDERED_LIST, OF_LABEL_MARKDOWN_UNORDERED_LIST],
            outputFormat
        );

        // Label for the done status

        const doneLabel = libdev.getString(preferences, PREF_DONE_LABEL);

        const doneLabelInput = new Form.Field.String(PREF_DONE_LABEL, LABEL_DONE_LABEL, doneLabel);

        // Generic projects

        const projectIds   = flattenedProjects.map(project => project.id.primaryKey);
        const projectNames = flattenedProjects.map(project => project.name);

        const genericProjectIds = libdev.getJson(preferences, PREF_GENERIC_PROJECTS, []);

        const genericProjects = new Form.Field.MultipleOptions(
            PREF_GENERIC_PROJECTS,
            LABEL_GENERIC_PROJECTS,
            projectIds,
            projectNames,
            genericProjectIds
        );

        // Ignored tags

        const tagIds   = flattenedTags.map(tag => tag.id.primaryKey);
        const tagNames = flattenedTags.map((tag) => {
            let label = tag.name;

            while (tag.parent !== null) {
                label = tag.parent.name + " : " + label;
                tag = tag.parent;
            }

            return label;
        });

        const ignoredTagIds = libdev.getJson(preferences, PREF_IGNORED_TAGS, []);

        const tagList = new Form.Field.MultipleOptions(
            PREF_IGNORED_TAGS,
            LABEL_IGNORED_TAGS,
            tagIds,
            tagNames,
            ignoredTagIds
        );

        // Preferences

        const preferenceForm = new Form();

        preferenceForm.addField(journalFolderOption);
        preferenceForm.addField(outputFormatOption);
        preferenceForm.addField(doneLabelInput);
        preferenceForm.addField(genericProjects);
        preferenceForm.addField(tagList);

        preferenceForm.validate = function (formObject) { return true; };

        const formPromise = preferenceForm.show("Work journal", "Save");

        formPromise.then((formObject) => {
            libdev.setString(preferences, PREF_JOURNAL_FOLDER, formObject);
            libdev.setString(preferences, PREF_OUTPUT_FORMAT, formObject);
            libdev.setString(preferences, PREF_DONE_LABEL, formObject);
            libdev.setJson(preferences, PREF_GENERIC_PROJECTS, formObject);
            libdev.setJson(preferences, PREF_IGNORED_TAGS, formObject);
        });
    }

    function get_work_logs() {
        const journalFolderId = libdev.getString(preferences, PREF_JOURNAL_FOLDER);

        if (journalFolderId === null) {
            throw { name: "Emmm...", message: "Work journal folder must be set in the preferences. (Click the action with CTRL key)" };
        }

        const ignoredTagIds = libdev.getJson(preferences, PREF_IGNORED_TAGS, []);

        const journal_date = new Date();

        let logs = new Array();

        Folder.byIdentifier(journalFolderId).flattenedProjects.forEach((proj) => {
            const completed_tasks = proj.flattenedTasks.filter(
                (task) =>
                    task.completed === true
                        && task.completionDate.toDateString() === journal_date.toDateString()
                        && ignoredTagIds.every((tagId) => !task.isTaggedUnder(Tag.byIdentifier(tagId)))
            );
            logs = logs.concat(completed_tasks);
        });

        return logs;
    }

    var action = new PlugIn.Action(function (selection, sender) {
        try {
            if (libdev.isPreferenceAction(sender)) {
                prompt_preferences_dialog();
            } else {
                const logs = get_work_logs();

                if (logs.length === 0) {
                    throw { name: "Emmm...", message: "Work journal is empty!" };
                }

                logs.sort((a, b) => {
                    if (a.completionDate > b.completionDate) {
                        return 1;
                    } else if (a.completionDate < b.completionDate) {
                        return -1;
                    } else {
                        return 0;
                    }
                });

                let logsByProject = {};

                logs.forEach((log) => {
                    const projectId = log.containingProject.id.primaryKey;
                    if (typeof logsByProject[projectId] === "undefined") {
                        logsByProject[projectId] = [log];
                    } else {
                        logsByProject[projectId].push(log);
                    }
                });

                let logStrings = [];

                const doneLabel         = libdev.getString(preferences, PREF_DONE_LABEL, '');
                const genericProjectIds = libdev.getJson(preferences, PREF_GENERIC_PROJECTS, []);

                for (const [projectId, logs] of Object.entries(logsByProject)) {
                    const logSubStrings = logs.map((log) => {
                        let logSubStringParts = [];

                        logSubStringParts.push(log.name);

                        // Filter out URLs
                        const urlPattern = /(?:https?):\/\/(\w+:?\w*)?(\S+)(:\d+)?(\/|\/([\w#!:.?+=&%!\-\/]))?/g;
                        const note = log.note.replaceAll(urlPattern, "").trim();

                        logSubStringParts.push(
                            note.length > 0 ? note.replaceAll("\n", " ") : doneLabel
                        );

                        return logSubStringParts.join(" ");
                    });

                    if (genericProjectIds.includes(projectId)) {
                        logStrings = logStrings.concat(logSubStrings);
                    } else {
                        logStrings.push(
                            logs[0].containingProject.name + " " + logSubStrings.join(" ")
                        );
                    }
                }

                const outputFormat = libdev.getString(preferences, PREF_OUTPUT_FORMAT);

                if (outputFormat === OF_KEY_MARKDOWN_ORDERED_LIST) {
                    logStrings = logStrings.map(log => '1. ' + log);
                } else if (outputFormat === OF_KEY_MARKDOWN_UNORDERED_LIST) {
                    logStrings = logStrings.map(log => '- ' + log);
                }

                Pasteboard.general.string = logStrings.join("\n");

                new Alert("Wow!", "Work journal has been put into the clipboard.").show();
            }
        } catch (err) {
            new Alert(err.name, err.message).show();
        }
    });

    action.validate = function (selection, sender) {
        if (libdev.isPreferenceAction(sender)) {
            return true;
        }

        try {
            const logs = get_work_logs();

            return logs.length > 0;
        } catch (err) {
            return false;
        }
    };

    return action;
})();
